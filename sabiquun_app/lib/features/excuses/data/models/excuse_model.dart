import 'package:sabiquun_app/features/excuses/domain/entities/excuse_entity.dart';

class ExcuseModel extends ExcuseEntity {
  const ExcuseModel({
    required super.id,
    required super.userId,
    required super.excuseDate,
    required super.excuseType,
    required super.affectedDeeds,
    super.description,
    required super.status,
    super.reviewedBy,
    super.reviewNotes,
    super.reviewedAt,
    required super.createdAt,
    required super.updatedAt,
  });

  factory ExcuseModel.fromJson(Map<String, dynamic> json) {
    // Parse excuse type
    final excuseTypeStr = json['excuse_type'] as String? ?? 'other';
    final excuseType = ExcuseType.fromString(excuseTypeStr);

    // Parse status
    final statusStr = json['status'] as String? ?? 'pending';
    final status = ExcuseStatus.fromString(statusStr);

    // Parse affected deeds (stored as JSONB in database)
    List<String> affectedDeeds = [];
    if (json['affected_deeds'] != null) {
      if (json['affected_deeds'] is Map) {
        // Check if it's {"all": true}
        final map = json['affected_deeds'] as Map;
        if (map['all'] != true) {
          // If not "all", it might be a map with deed IDs as keys
          affectedDeeds = map.keys.map((e) => e.toString()).toList();
        }
        // If it's {"all": true}, leave affectedDeeds empty
      } else if (json['affected_deeds'] is List) {
        affectedDeeds = (json['affected_deeds'] as List)
            .map((e) => e.toString())
            .toList();
      }
    }

    return ExcuseModel(
      id: json['id'] as String,
      userId: json['user_id'] as String,
      excuseDate: DateTime.parse(json['report_date'] as String),
      excuseType: excuseType,
      affectedDeeds: affectedDeeds,
      description: json['description'] as String?,
      status: status,
      reviewedBy: json['reviewed_by'] as String?,
      reviewNotes: json['rejection_reason'] as String?,
      reviewedAt: json['reviewed_at'] != null
          ? DateTime.parse(json['reviewed_at'] as String)
          : null,
      createdAt: DateTime.parse(json['created_at'] as String),
      updatedAt: json['updated_at'] != null
          ? DateTime.parse(json['updated_at'] as String)
          : DateTime.parse(json['created_at'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'user_id': userId,
      'report_date': excuseDate.toIso8601String().split('T')[0],
      'excuse_type': excuseType.name,
      'affected_deeds': affectedDeeds.isEmpty ? {'all': true} : affectedDeeds,
      'description': description ?? '',
      'status': status.name,
      'reviewed_by': reviewedBy,
      'rejection_reason': reviewNotes,
      'reviewed_at': reviewedAt?.toIso8601String(),
      'created_at': createdAt.toIso8601String(),
    };
  }

  ExcuseEntity toEntity() {
    return ExcuseEntity(
      id: id,
      userId: userId,
      excuseDate: excuseDate,
      excuseType: excuseType,
      affectedDeeds: affectedDeeds,
      description: description,
      status: status,
      reviewedBy: reviewedBy,
      reviewNotes: reviewNotes,
      reviewedAt: reviewedAt,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  // For creating new excuse requests
  factory ExcuseModel.create({
    required String userId,
    required DateTime excuseDate,
    required ExcuseType excuseType,
    required List<String> affectedDeeds,
    String? description,
  }) {
    final now = DateTime.now();
    return ExcuseModel(
      id: '', // Will be generated by Supabase
      userId: userId,
      excuseDate: excuseDate,
      excuseType: excuseType,
      affectedDeeds: affectedDeeds,
      description: description,
      status: ExcuseStatus.pending,
      createdAt: now,
      updatedAt: now,
    );
  }
}
